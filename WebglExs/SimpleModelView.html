<!DOCTYPE html>
<html lang="en">
        <head>
                <title>Multi-resolution LOD chain for on-line visualization | Simple model view</title>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
                <link rel="stylesheet" href="threejs.css" type="text/css" media="all" />
        </head>

        <body>
                <script src="js/three.js"></script>
                <script src="js/STLLoader.js"></script>

                <script>

                        var container;
                        var camera, scene, renderer;

                        var models = [];
			var files = new Array("cane1M-99.99.stl", "cane1M-99.9.stl", "cane1M-99.stl" , "cane1M-90.stl") ;

                        var filesLoaded = 0, currentModel;

                        var meshMaterial = new THREE.MeshPhongMaterial( { ambient: 0xff5533, color: 0xff5533, specular: 0x111111, shininess: 200 } );

                        var clock = new THREE.Clock();
                        clock.start();

                        init();
                        load_model(files[0]);
                        animate();

                        function load_model(modelName) {
                                var loader = new THREE.STLLoader();

                                loader.addEventListener( 'load', function ( event ) {
                                        var geometry = event.content;
                                        // geometry.dynamic = true;
					// geometry.buffersNeedUpdate = true;
                                        geometry.name = modelName;
                                        console.log(modelName + ' loaded -> vertices: ' + geometry.vertices.length + ' faces: ' + geometry.vertices.length);

					models[filesLoaded] = geometry;
					update_mesh_geometry(geometry);
                                } );
                                loader.load( 'data/' + modelName);
                                console.log('starting loading ' + modelName);
                        }

                        function load_next_model() {
                                if (models[filesLoaded] != undefined) { // current model has been loaded
                                        filesLoaded++;
                                        console.log('requesting to load: ' + files[filesLoaded]);
                                        load_model(files[filesLoaded]);
                                }

                        }

                        function update_mesh_geometry(geometry) {
                                var mesh = scene.getObjectByName("STLModel", true);
				if (mesh != undefined) {
					scene.remove(mesh);
				}

				console.log('creating new mesh for ' + geometry.name);

				var mesh = new THREE.Mesh( geometry, meshMaterial );

				mesh.name = "STLModel";
				mesh.position.set( 2, 0, 2 );
				mesh.rotation.set( 0, 0, 0 );
				mesh.scale.set( 0.004, 0.004, 0.004 );

				mesh.castShadow = true;
				mesh.receiveShadow = true;

				console.log('created new mesh, id: ' + mesh.id);
				scene.add( mesh );
			}

                        function onWindowResize() {
                                camera.aspect = window.innerWidth / window.innerHeight;
                                camera.updateProjectionMatrix();

                                renderer.setSize( window.innerWidth, window.innerHeight );
                        }

                        function animate() {
                                requestAnimationFrame( animate );

                                var timer = Date.now() * 0.0005;

                                camera.position.x = Math.cos( timer ) * 5;
                                camera.position.z = Math.sin( timer ) * 5;

                                camera.lookAt( cameraTarget );

                                render();
                        }

                        function render() {

                                // start loading next file when previous loading fineshed
                                if (filesLoaded < files.length-1)
                                        load_next_model();
                                else {
                                        // @TODO: do something about timing !!!
                                        // update_mesh_geometry(models[currentModel++]);
                                }

                                /*
                                var timer2 = clock.getElapsedTime()/15;
                                if (timer2 > 3) {
                                        console.log('time to load new model: ' + timer2);
                                        load_model_mesh(files[1]);
                                        clock = new THREE.Clock();
                                }
                                else if (timer2 > 2) {
                                        console.log('time to load new model: ' + timer2);
                                        load_model_mesh(files[1]);
                                        clock = new THREE.Clock();
                                }
                                else if (timer2 > 1) {
                                        console.log('time to load new model: ' + timer2);
                                        load_model_mesh(files[1]);
                                        clock = new THREE.Clock();
                                }
                                */

                                renderer.render( scene, camera );
                        }

                        function init() {

                                container = document.createElement( 'div' );
                                document.body.appendChild( container );

                                camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 15 );
                                camera.position.set( 3, 0.15, 3 );

                                cameraTarget = new THREE.Vector3( 0, -0.25, 0 );

                                scene = new THREE.Scene();
                                scene.fog = new THREE.Fog( 0x72645b, 2, 15 );


                                // Ground
                                var plane = new THREE.Mesh( new THREE.PlaneGeometry( 40, 40 ), new THREE.MeshPhongMaterial( { ambient: 0x999999, color: 0x999999, specular: 0x101010 } ) );
                                plane.rotation.x = -Math.PI/2;
                                plane.position.y = -0.5;
                                scene.add( plane );

                                plane.receiveShadow = true;


                                // Lights
                                scene.add( new THREE.AmbientLight( 0x777777 ) );

                                addShadowedLight( 1, 1, 1, 0xffffff, 1.35 );
				addShadowedLight( 0.5, 1, -1, 0xffaa00, 1 );

                                // renderer
                                renderer = new THREE.WebGLRenderer( { antialias: true, alpha: false } );
                                renderer.setSize( window.innerWidth, window.innerHeight );

                                renderer.setClearColor( scene.fog.color, 1 );

                                renderer.gammaInput = true;
                                renderer.gammaOutput = true;
                                renderer.physicallyBasedShading = true;

                                renderer.shadowMapEnabled = true;
                                renderer.shadowMapCullFace = THREE.CullFaceBack;

                                container.appendChild( renderer.domElement );

                                window.addEventListener( 'resize', onWindowResize, false );
                        }

                        function addShadowedLight( x, y, z, color, intensity ) {

                                var directionalLight = new THREE.DirectionalLight( color, intensity );
                                directionalLight.position.set( x, y, z )
                                scene.add( directionalLight );

                                directionalLight.castShadow = true;
                                // directionalLight.shadowCameraVisible = true;

                                var d = 1;
                                directionalLight.shadowCameraLeft = -d;
                                directionalLight.shadowCameraRight = d;
                                directionalLight.shadowCameraTop = d;
                                directionalLight.shadowCameraBottom = -d;

                                directionalLight.shadowCameraNear = 1;
                                directionalLight.shadowCameraFar = 4;

                                directionalLight.shadowMapWidth = 1024;
                                directionalLight.shadowMapHeight = 1024;

                                directionalLight.shadowBias = -0.005;
                                directionalLight.shadowDarkness = 0.15;
                        }

                </script>
        </body>
</html>
